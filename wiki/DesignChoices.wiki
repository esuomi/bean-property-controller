#summary Explanations of the various design choices of BPC
#labels Phase-Design

= Before we delve into details... =

By concious decision BeanPropertyController breaks away from common conventions for various reasons which are discussed in detail below. This is admittedly a bit of a contradiction because BPC's functionality is made entirely possible only by the fact that Java is heavily based on conventions, especially the Java beans themselves. BPC also breaks away from all kinds of Java bean conventions quite fast if you look closer into its API but as with other design details, keep reading to find out more.

= Design decisions and specifics =

== Accessor/mutator method naming ==

If you step back a bit and consider the famous `getter/setter` method pair of beans as what they represent instead of something you just autogenerate in Eclipse, you should know that they're really called accessors and mutators for object's specific property. This is the number one reason why instead of `get(String propertyName)` BPC provides `access(String propertyName)` and similarly why `set(String propertyName, Object value)` is replaced with `mutate(String propertyName, Object value)`. The idea is to signify that you are controlling another object and BPC itself isn't a bean but a class with specific functionality and thus I want to discourage users from using it as a bean but an utility instead for doing this specific task.

== BeanPropertyController object construction ==

Instead of providing a constructor a bunch of factory methods are provided instead, namely the `of()` methods. This is partly because BPC needs certain set of values whenever it's constructed and while it could've been done with constructors, `BeanPropertyController.of(someObject)` is easier to understand than `new BeanPropertyController(someObject)`. Note that this sort of naming convention for construction isn't unique, [http://java.sun.com/j2se/1.5.0/docs/api/java/util/EnumSet.html Java's EnumSet] uses the same paradigm too and so does [http://code.google.com/p/google-collections/ Google Collections].

== Lazy loading ==

Although in automated environment it's not obvious, BPC is a lazy-loading utility. That is, every single extracted property is extracted only when they're actually needed. Understandably `getPropertyNames()` completely nullifies this feature since it scans the entire controlled object but the goal here was to provide a slightly more memory efficient extraction tool for situations where you know the name of the properties you're interested of beforehand. Each extracted property is of course cached so the extraction is done only once.

== Everything in one package ==

The reason everything is in one package is that in Java there isn't a visibility modifier for "current package and it's subpackages" and I felt the need to limit the available API quite heavily. The reason is that it's much easier to expose new methods than deprecate old ones and also the internal API isn't in a stable state yet although the functionality is there.

== Undetachable BeanProperty ==

Some other similar implementations have detachable BeanProperties, that is you can actually acquire a list of BeanProperty classes from the controller object and use those to control individual property. While this is sort of nice in some cases, the issue here is that such functionality
  * leaks abstraction and exposes internals of the actual utility and
  * makes reusability annoying to do - for example BPC's `recycle()` couldn't be done easily with detachable properties without at least losing performance

== Breaking conventions with bean handling ==

While some (possibly outdated) documentation exists in the actual BeanPropertyController class for these, here's an explanation for the various options you can use when constructing BPC.

=== ExtractionDepth ===

Extraction depth is the second biggest convention breaker in BPC, it basically allows you to choose how deeply the object is scanned for detecting properties.
  * `METHODS` (which is the default) scans only methods which fall into common conventions (`[is/get]X() / setX(T x)`)
  * `FIELDS` includes actual fields to the scanning meaning that a mutable property may be formed from `getX()` and field with matching name that isn't a declared field
  * `QUESTIMATE` is the "everything goes" option in which otherwise inaccessible declared fields are also included to the scan

=== InstantiationPolicy ===

Biggest. Convention breaker. Ever. Currently has two options:
  * `NO_ARGS`, default behaviour, searches for the constructor with 0 arguments and uses that
  * `NICE`, uses nice values (zeros, `false`, `""` and so on) to instantiate the object with its shortest available constructor. Doesn't currently handle beans within beans, that may change in the future

Also in future versions the following may be available too:
  * `JVM_FORCED_INSTANTIATION` Force creation of instance using JVM internals even if public constructor doesn't exist. I already know how to do this with Sun's JVM and if this is specifically requested, I will add it.
  * `PROXY_INSTANCE` for creating a proxy which mimics the given class, think creating ad hoc beans from interfaces.

=== stepping ===

Consider beans within beans, such as `Person` who has a `House` that has an `Address`. To get to the house number from person you'd traditionally write `person.getHouse().getAddress().getHouseNumber()`, with BPC this same is done with property String `house.address.houseNumber`. Since this is part of a recursive scan into the object, a way to limit this has been provided.

Default stepping is -1 which means infinite stepping, otherwise the number specifies how many steps into the bean's internal structure can be taken. In the example above stepping of 1 would limit the `house` to address and 2 would limit the access to `address`.